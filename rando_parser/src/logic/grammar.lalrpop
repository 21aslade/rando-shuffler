use std::convert::Infallible;

use crate::{Ident, FullIdent};

use super::lexer::{Tok, Arrow};
use super::ast::*;

grammar<'input>(input: &'input str);

pub Tree = Scope*;

Scope: Scope<'input> = {
    <keyword:"keyword"> <name:"ident"> "\n" => Scope { children: ScopeChild::None, <> },
    <keyword:"keyword"> <name:"ident"> ":" "\n" "indent" <c:Scope+> "dedent" => Scope { keyword, name, children: ScopeChild::Scope(c) },
    <keyword:"keyword"> <name:"ident"> ":" "\n" "indent" <c:RoomItem+> "dedent" => Scope { keyword, name, children: ScopeChild::Room(c) },
};

RoomItem: RoomItem<'input> = {
    "node" <name:"ident"> "\n" => RoomItem::Node(Node { <>, children: Vec::new(), modify: false }),
    "node" <name:"ident"> <m:"+"?> ":" <children:Descriptors> => RoomItem::Node(Node { name, children, modify: m.is_some() }),
    <left:"ident"> <arrow:"arrow"> <right:"ident"> "\n" => RoomItem::Connection(Connection { logic: Vec::new(), <>}),
    <left:"ident"> <arrow:"arrow"> <right:"ident"> ":" <logic:EdgeLogic> => RoomItem::Connection(Connection { <> })
};

Descriptors: Vec<Descriptor<'input>> = {
    "\n" "indent" <(<Descriptor> "\n")+> "dedent",
    InlineDescriptors
};

#[inline]
InlineDescriptors: Vec<Descriptor<'input>> = <d:Descriptor> <v:("," <Descriptor>)*> ","? "\n" => {
    let mut v = v;
    v.insert(0, d); // Order matters for errors
    v
};

Descriptor: Descriptor<'input> = {
    <keyword:"keyword"> <idents:FullIdent*> => Descriptor { keyword, idents }
};

FullIdent: FullIdent<'input> = {
    <i:"ident"> <v:("." <"ident">)*> => {
        let mut v = v;
        v.insert(0, i);
        FullIdent::Namespaced { idents: v }
    },
    <ident:"global"> => FullIdent::Global { ident }
};


EdgeLogic: Vec<EdgeLogic<'input>> = {
    <LogicSugar> "\n" => vec![<>],
    <InlineDescriptors> "\n" => <>.into_iter().map(EdgeLogic::Descriptor).collect(),
    "\n" "indent" <(<EdgeTree> "\n")+> "dedent"
};

EdgeTree: EdgeLogic<'input> = {
    "&" ":" <EdgeLogic> => EdgeLogic::And(<>),
    "|" ":" <EdgeLogic> => EdgeLogic::Or(<>),
    Descriptor => EdgeLogic::Descriptor(<>),
};

LogicSugar: EdgeLogic<'input> = "(" <LogicSugarBody> ")";

LogicSugarBody: EdgeLogic<'input> = {
    And,
    Or
};

And: EdgeLogic<'input> = <k: ConditionItem> <v:("&" <ConditionItem>)*> => {
    let mut v = v;
    v.push(k);
    EdgeLogic::And(v)
};

Or: EdgeLogic<'input> = <k: ConditionItem> <v:("|" <ConditionItem>)+> => {
    let mut v = v;
    v.push(k);
    EdgeLogic::Or(v)
};

ConditionItem: EdgeLogic<'input> = {
    LogicSugar,
    Descriptor => EdgeLogic::Descriptor(<>)
};

extern {
    type Location = usize;
    type Error = Infallible;

    enum Tok<'input> {
        "\n" => Tok::Newline,
        "indent" => Tok::Indent,
        "dedent" => Tok::Dedent,
        "node" => Tok::Node,
        "keyword" => Tok::Keyword(<&'input str>),
        "ident" => Tok::Ident(<Ident<'input>>),
        "global" => Tok::Global(<Ident<'input>>),
        "arrow" => Tok::Arrow(<Arrow>),
        ":" => Tok::Colon,
        "." => Tok::Period,
        "," => Tok::Comma,
        "+" => Tok::Plus,
        "*" => Tok::Star,
        "&" => Tok::And,
        "|" => Tok::Or,
        "(" => Tok::OpenParen,
        ")" => Tok::CloseParen,
    }
}